{"./":{"url":"./","title":"Introduction","keywords":"","body":"Introduction gitbook上传 1. cd F:\\Typora数据储存\\gitbook_blog 2. cmd上：进入H:\\software\\nvm\\v12.16.3\\node_global\\gitbook build ./ ./docs 3. 在gitbook_blog 目录中打开gitbash 4. git add ./docs 5. git commit -m “message” 6. git push origin gitbook_blog gitbook插件 https://segmentfault.com/a/1190000019806829 git .gitignore 文件不生效 git rm -r --cached . powered by Gitbook该文件最后修改时间： 2021-09-26 23:47:24 "},"配置中心/disConf.html":{"url":"配置中心/disConf.html","title":"DisConf","keywords":"","body":"简介 Distributed Configuration Management Platform（分布式配置管理） https://blog.csdn.net/qinxuefly/article/details/53287189 模块架构图 客户端使用流程 导入jar包 com.baidu.disconf disconf-client 2.6.30 在classpath.xml添加Disconf启动支持 classpath*:dms-admin.properties 在客户端应用的classpath下新增disconf.properties文件 disconf.properties会在DIsconfMgrBean注册时(实现了BeanDefinitionRegistryPostProcessor接口，成功注册了BeanDefinition，使得之后BeanFactory使用BeanDefinition进行Bean的实例化、注入属性，前置后置处理、实现Aware接口，初始化垫了基础)在FirstScan方法调用时被读取入DisClientConfig对象中 # 是否使用远程配置文件 # true(默认)会从远程获取配置 false则直接获取本地配置 enable.remote.conf=true # # 配置服务器的 HOST,用逗号分隔 127.0.0.1:8000,127.0.0.1:8000 # conf_server_host=127.0.0.1:8080 # 版本, 请采用 X_X_X_X 格式 version=1_0_0_0 # APP 请采用 产品线_服务名 格式 app=disconf_demo # 环境 env=rd # debug debug=true # 忽略哪些分布式配置，用逗号分隔 ignore= # 获取远程配置 重试次数，默认是3次 conf_server_url_retry_times=1 # 获取远程配置 重试时休眠时间，默认是5秒 conf_server_url_retry_sleep_seconds=1 详细设计请参考： http://disconf.readthedocs.io/zh_CN/latest/design/index.html 配置项注解使用 为这个类定义 @DisconfFile 注解，指定文件名为 code.properties 。 定义域codeError，并使用Eclipse为其自动生成 get&set 方法。 为该域的get方法上添加注解 @DisconfFileItem 。添加标记 name, 表示配置文件中的KEY名，这是必填的 标记associateField是可选的，它表示此get方法相关连的域的名字，如果此标记未填，则系统会自动 分析get方法，猜测其相对应于域名。强烈建议添加associateField标记，这样就可以避免Eclipse生成的Get/Set方法不符合 Java规范的问题。 标记它为Spring托管的类 （使用@Service），且 \"scope\" 都必须是singleton的。 5.配置更新回调 实现IDisconfUpdate接口，并且该类是由spring管理 注解@DisconfUpdateService， confFileKeys为监控配置文件更新，itemKeys为监控配置项更新 @Slf4j @Configuration @Component @DisconfFile(filename = \"producer.kafka.value.json\") @DisconfUpdateService(classes = {KafkaProducerBeanFactory.class}) public class KafkaProducerBeanFactory implements InitializingBean,IDisconfUpdate{ 若是程序本身：程序不会自动reload配置，需要自己写回调函数(实现IDisconfUpdate接口，并添加DisconfUpdateService注解)。 若仅仅是托管文件本身： classpath*:dms-admin.properties 服务端部署 Linux：https://blog.csdn.net/qinxuefly/article/details/53287189 windows：https://www.jianshu.com/p/131c56f2a934 疑问 4.1 Disconf怎么做到实时修改？ Disconf主要是依靠zookeeper的Watch机制来做配置实时修改的,我们都知道ZK是通过目录挂载的方式来做服务的自动注册与发布。客户端启动时注册了一个回调接口,当zk目录发生变化时会回调所有客户端节点,从而做到\"实时\"更新配置的目的。 4.2 Disconf怎么做到数据持久化？ 在配置中心添加的配置数据都被持久化到了DB中,每次客户端启动的时候会调用Disconf的Http接口获取最新的配置数据,如果网络不通,默认会重试三次,如果还不通,则抛出异常。如果第一次拉取配置就有问题,作为配置中心来讲是肯定是无解的,需要客户端去解决（一般这种情况是网络问题或者配置中心服务不可用导致）。 我们这里不需要考虑第一次加载配置就失败的情况.那么问题来了： 1.如果第一次加载配置后,配置中心不可用,会影响到客户端吗？答案：不会。因为动态修改的配置已经加载到内存了,是不影响的。 2.如果配置中心宕机,加上客户端需要发布新版本面临重启呢？答案：不影响,因为第一次从配置中心拉取配置后会持久化到磁盘固定目录上,如果配置中心不可用,会读取缓存文件的数据(需要做文件防篡改操作) 4.3 如果ZK宕机会影响配置中心使用吗？ 答案:不会,因为disconf会单独起一个线程做重连操作。 4.4 Disconf怎么保证同一项目、环境所在节点都修改配置成功。 答案:没有做这方面的保证。因为客户端连接到配置中心上以后会将机器名挂载到zk目录下,可以通过界面查看配置使用的机器数。 Disconf自定义功能扩展 1 客户端接入功能增强,增加默认配置属性。 2 Disconf针对key-value配置属性没有做持久化,当配置中心宕机、客户端重启时无法拉取历史配置信息。 3 增强Disconf节点之间配置不同步的问题 4 去掉修改配置同步发送功能,改成异步(它采用的是同步发送,非常卡慢) 配置时各个bean的作用 DisconfMgrBean 此Bean实现了BeanFactoryPostProcessor和PriorityOrdered接口。它的Bean初始化Order是最高优先级的。 因此，当Spring扫描了所有的Bean信息后，在所有Bean初始化（init）之前，DisconfMgrBean的postProcessBeanFactory方法将被调用，在这里，Disconf-Client会进行第一次扫描。 扫描按顺序做了以下几个事情： 初始化Disconf-client自己的配置模块。 初始化Scan模块。 初始化Core模块，并极联初始化Watch，Fetcher，Restful模块。 扫描用户类，整合分布式配置注解相关的静态类信息至配置仓库里。 执行Core模块，从disconf-web平台上下载配置数据：配置文件下载到本地，配置项直接下载。 配置文件和配置项的数据会注入到配置仓库里。 使用watch模块为所有配置关联ZK上的结点。 DisconfMgrBeanSecond DisconfMgrBean的扫描主要是静态数据的初始化，并未涉及到动态数据。DisconfMgrBeanSecond Bean则是将一些动态的数据写到仓库里。 本次扫描按顺序做了以下几个事情： 将配置更新回调实例放到配置仓库里 为配置实例注入值。 当DisconfMgrBean第一次扫描时，watcher监控不到相应的类时，但是对应的disconf.user_define_download_dir中再本地存在相应的properties，MgrBeanSecond也能执行注入 ReloadablePropertiesFactoryBean ReloadablePropertiesFactoryBean继承了PropertiesFactoryBean类，它主要做到： 托管配置文件至disconf仓库，并下载至本地。 解析配置数据传递到 ReloadingPropertyPlaceholderConfigurer ReloadingPropertyPlaceholderConfigurer ReloadingPropertyPlaceholderConfigurer继承自Spring的配置类PropertyPlaceholderConfigurer，它会在Spring启动时将配置数据与Bean做映射，以便在检查到配置文件更改时，可以实现Bean相关域值的自动注入。 如果想配置文件，但是不想自动reload，那么该怎么办？ myserver.properties 在这里，myserver.properties被disconf托管，当在disconf-web上修改配置文件时，配置文件会被自动下载至本地，但是不会reload到系统里。 ReloadConfigurationMonitor 它是一个Timer类，定时校验配置是否有更改，进而促发 ReloadingPropertyPlaceholderConfigurer 类来分析要对哪些 Bean实例进行重新注入。 powered by Gitbook该文件最后修改时间： 2021-09-26 22:24:52 "},"项目结构/ccs项目结构.html":{"url":"项目结构/ccs项目结构.html","title":"Ccs项目结构","keywords":"","body":"数据结构设计 项目模块的结构 ccs-business： 项目业务服务代码的实现模块 ccs-cache: Redis 缓存的具体配置功能，在bean.xml中实现了对tm_config和xxx的redis启动刷新 ccs-web：web项目构建模块 ccs-common:这是项目的公共模块，主要用到的有Util包中的JsonUtil和HttpUtil用于别的系统接口调用和对cache取出的config等json包进行映射使用 gradle 配置 项目通过gradle-eclipse 清理项目eclipse配置和 启动eclipse task和eclipseJettyLaunch task eclipse和 eclispseJettyLaucn 都是为了加载eclipse的classpath配置等 同时因为项目的Build LifeStyle因此初始化了gradle 的Project对象,并触发了项目的build.gradle，给Project添加配置,通过setting.gradle的include Task 导入了其他模块的build gradle. 而gradle中设置最多的便是project 的 gradle配置 其中需要添加什么依赖可以到project模块的build.gradle添加依赖 javaProject.gradle 定义了项目以java形式运行时的配置如output的路径 jibx.gradle是一个为Java提供的XML数据绑定框架,但是系统中没看到 webappProject.gradle 是打包时的配置的,如清除webapp生成数据的cleanWebappRuns和服务运行的jetty容器配置等 包的结构 设计一个后台功能大概需要涉及的包(ccs-business): rest(Controller模块,返回给前端的需要用Reslut/RestResult封装返回) manager层,service层,biz层 manager层： 负责将Dao层中的数据库操作组合复用，主要是一些缓存方案，中间件的处理，以及对第三方平台封装的层。 service层： 更加关注业务逻辑，是业务处理层，将manager组合过的操作和业务逻辑组合在一起，再封装成业务操作。 biz层： 包含service层，service层注重基础业务的处理，biz层是复杂应用层的业务层。 repository,dao(若是用到数据库映射框架,都是hibernate) 公司的dao层主要面对本系统内部的,直接面对数据库的 repository是需要通过https获取其他系统的数据,再面向数据库的 domain(dto/request等数据对象,用hibernate的话可以用xml或者在dto对象上用@table注释) 数据库方面:目前只知道dms和tms 的测试数据库地址,ccs和excp都不认识 前端交互流程 1、评审阶段：产品召集前后端进行需求评审，前后端各自捋清楚自己的业务量以及联调之间工作量，从而进行开发时间评估。 2、开发准备阶段：前后端一起商量需求中需要联调的部分，进行接口的口头协议交流。 3、接口定义阶段：前后端中的一方根据之前的口头协议拟定出一份详细的接口，并书写APl文档，完成后由另一方确认。有疑问的地方重新商量直至双方都没有问题。 4、开发阶段：双方根据协商出来的接口为基础进行开发，如在开发过程中发现需要新增或删除一些字段，重复步骤3。 注意：前端在开发过程中记得跟进接口，mock数据进行本地测试。 5、联调阶段：双方独自的工作完成，开始前后端联调，如在联调过程发现有疑问，重复步骤3，直至联调完成。 6、产品体验阶段：将完成的需求交给产品，让其体验，直至产品这边没有问题 7、提测阶段：将完成的需求提给测试人员，让其对该需求进行测试，如发现问题，及时通知开发并让其修改，直至需求没有bug。 8、评审单发布阶段：前后端中的一人进行评审单的拟定，发送给对应的领导，表明需求发布的程序，包括影响到的页面及业务，发布的流程，发布的回滚方案等。 9、发布阶段：前后端双方在保证步骤1—8都没有问题了，进行各自的代码发布，完成后由测试人员在线上进行相应的测试，如果有bug，重复步骤7和9，直至需求成功上线。 可以在我开发前先提供一些需要的参数,先设定各个方法需要的dto的属性,和接口名等信息 也可以在我做完后再一起提供接口名和dto信息,方便前端联调 接口注意事项 接口命名 查询 queryXXX/getXXX 插入 insertXXX/addXXX 更新 updateXXX 删除 deleteXXX 判断 checkXXX(数据库用is_xxx,但需要表明映射) 统计 staticXXX 代码质量 接口是没有静态代码块的statci{}，也没有构造方法，一个类的父类只能有一个，但是一个类可以同时实现多个接口 格式：public class Myinterfaceimpl implements MyinterfaceA,MyInterfaceB{覆盖重写所有的抽象方法} 如果多个接口含有相同的抽象方法，则直接重写一回即可 如果没有覆盖重写全部的，必须是抽象类 接口中有相同的默认方法必须要重写，抽象类中也要重写 一个类如果直接父类的方法与接口的默认方法冲突，优先使用父类的方法*/ 注释文档 个人的困惑 编程的时候,刚开始初步浪费时间的较多的地方,便是在数据库和dto,方法等的命名上,对于各自的系统,应该各自对高频关键字应该有一份推荐的模板,有益于提高开发效率,也减少以后阅读维修的难度 对于各个中间件,如redis和kafka,最好注释或者文档能清晰的标识其配置逻辑、已经使用的有哪些与能哪些类型的功能需要被使用的情况，不然刚上手如我现在需要问人是否要先从cache中获取，以及是否有获取不到的情况放到数据库中还是刷新缓存等处理 对于需求，对于一些需求有什么特殊的配置需求（存储、中间件使用等），可以共同编辑到需求文档中，如现在的添加配置用tm_config这张表而不是新建表。 对于前端后台交互，针对一些直接交互的控件：哪个功能是后台逻辑实现哪个是前端实现可以先前期交流并加入到需求文档中 对于数据库、表的功能还有各个的测试环境地址，小组有专门的文档，可以加快项目的理解速度，而不需要找到各个功能的dao层去查看 powered by Gitbook该文件最后修改时间： 2021-08-08 22:35:20 "}}